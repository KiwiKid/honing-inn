package main

import (
    "fmt"
)


templ shapePopupManage(shapes []Shape, shapeTypes []ShapeType){
    @shapeSelector(shapes)
    <!--<details>
    <summary>Start New Area</summary>
    @addShapeForm(shapeTypes)
    </details>-->
}

templ shapeSelector(shapes []Shape){
    if (len(shapes) > 0) {
        <select name="shape">
            for _, shape := range shapes {
                <option value={fmt.Sprintf("%d", shape.ID)} >{shape.ShapeTitle}</option>
            }
        </select>
    }
}

templ addShapeForm(meta ShapeMeta){
    <form hx-post="/shapes?updateMode=create-area">
    <script>
          document.getElementById('shapeData').value = JSON.stringify(window.existingNewAreaPoints || []);
    </script>
        <input type="hidden" id="shapeData" name="shapeData"></input>
        <label>shapeTitle: <input name="shapeTitle"></input></label>
         <label><select name="shapeKind">shapeKind
                for _, kind := range meta.kinds {
                    <option value={  kind.Name}>{kind.Name}</option>
                }
            </select></label>
        <label>shapeType: 
            <select name="shapeType">
                for _, st := range meta.types {
                    <option value={ st.Name}>{st.Name}</option>
                }
            </select>
        </label>
        <button type="submit">save</button>
        @refreshButton("cancel","")
    </form>
}

templ editShapeForm(shape Shape, meta ShapeMeta, msg string){
     <form hx-post="/shapes?updateMode=create-area" class="w-10" hx-target="this">
        if len(msg) > 0 {
            @success(msg)
        }
         <input type="hidden" name="shapeData" value={shape.ShapeData}></input>
        <label>shapeTitle: <input name="shapeTitle" value={shape.ShapeTitle}></input></label>
         <label><select name="shapeKind">shapeKind
                for _, kind := range meta.kinds {
                    <option value={  kind.Name}
                        if kind.Name == shape.ShapeKind {
                            selected="selected"
                        }
                    >{kind.Name}</option>
                }
            </select></label>
        <label>shapeType: 
            <select name="shapeType">
                for _, st := range meta.types {
                    <option value={ st.Name}
                         if st.Name == shape.ShapeType {
                            selected="selected"
                        }
                    >{st.Name}</option>
                }
            </select>
        </label>
        <button type="submit">update</button>
        <button hx-delete={ fmt.Sprintf("/shapes/%d", shape.ID) }>delete</button>
    </form>
}

templ shapeList(shapes []Shape, shapeMeta ShapeMeta, homes []Home){
   
 <script>
    
        console.log('shape list js')
        

        // Function to collect and process shapes and homes
        function processShapesAndHomes() {

            console.log('shape list js - processShapesAndHomes')
            // Group shapes into layers
            window.shapeLayers = {};

                console.log(' Add home markers')

           document.querySelectorAll('span[data-shape-id]').forEach(function(element) {
                console.log('Processing shapes');
                if (element.getAttribute('rendered') !== 'true') {
                    const shapeData = JSON.parse(element.getAttribute('data-shape-data'));
                    const shapeId = element.getAttribute('data-shape-id');
                    const shapeKind = element.getAttribute('data-shape-kind');

                    // Get the corresponding layer group for the shape kind
              
                    // Add the polygon to the layer group
                    window.mapActor.addPolygon(shapeData, { shapeKind: shapeKind, shapeId: shapeId }, window.mapActor.editAreaPopupOptions)
                       

                    element.setAttribute('rendered', 'true');
                }
            }.bind(this)); // Bind 'this' to ensure 'this.map' is accessible

            console.log('Adding home markers');

            // Add home markers
            document.querySelectorAll('span[data-home-id]').forEach(function(element) {
                console.log('Processing homes');
                if (element.getAttribute('rendered') !== 'true') {
                    const lat = parseFloat(element.getAttribute('data-lat'));
                    const lng = parseFloat(element.getAttribute('data-lng'));
                    const homeId = element.getAttribute('data-home-id');
                    const pointKind = element.getAttribute('data-point-kind');

                    window.mapActor.addMarker(lat, lng, { homeId, pointKind })
                    // Add the marker to the 'homes' layer group
                    /*L.marker([lat, lng])
                        .addTo(overlayMaps.homes)
                        ;*/

                    element.setAttribute('rendered', 'true');
                }
            });
        }

        // Initialize map and process shapes and homes
            processShapesAndHomes();
    </script>
     for _, h := range homes {
        @homeShape(h)
    }
    
    for _, s := range shapes {
        switch s.ShapeType {
            case "area":
                
                @areaShape(s)
            default:
                console.info("shape type not supported")
                @warning(fmt.Sprintf("shape ShapeType not valid (%s) on %+v", s.ShapeType, s))
            
        }
    }

   

}
templ areaShape(shape Shape) {
    <span 
        data-shape-data={ templ.JSONString(shape.ShapeData) } 
        data-shape-id={ fmt.Sprintf("%d", shape.ID) }  
        data-shape-kind={ shape.ShapeKind }>
    </span>
}

templ homeShape(h Home) {
    <span 
        data-lat={ fmt.Sprintf("%f", h.Lat) } 
        data-lng={ fmt.Sprintf("%f", h.Lng) } 
        data-home-id={ fmt.Sprintf("%d", h.ID) } 
        data-point-kind={ h.PointType }>
    </span>
}